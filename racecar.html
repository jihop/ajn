<!doctype html>
<html>
    <head>
        <!-- Load the Paper.js library -->
        <script src="js/paper.js"></script>
        <script src="js/Track.js"></script>

        <!-- Define inlined PaperScript associate it with myCanvas -->
        <script type="text/paperscript" canvas="myCanvas">
		
            ////////// START GAME CONTROLLER //////////
            var config_SegmentDistancePixels = 100.0;
            var config_LaneWidthPixels = 100.0;
            var game,
                autoStartGame = false; // for quick debuggin
            
            (function() {
                function GameController() {
                // show game menu
                console.log('show game menu');
                };
                
                GameController.prototype.initialize = function() {
					this.clock = new Clock();
					var intitialVelocity = new Point(0,-15);
					this.playerLayer = project.activeLayer;
					this.player1 = new Player(300, 0, "redcar", intitialVelocity);
                    this.player2 = new Player(200, 0, "yellowcar", intitialVelocity);
                }
				
				GameController.prototype.start = function() {
					this.track = new Track();
					this.player1.raster.bringToFront();
					this.player2.raster.bringToFront();
		    //Horizontal adjustment needed for the camera of about 500, because rasters are weird
		    // and don't report position or rect correctly
                    this.camera = new Camera(this.track.baseRaster.position, this.track.baseRaster.bounds, 500);
                    this.active = true;
				}
				
                game = new GameController();
            })();
            ////////// END GAME CONTROLLER //////////
			
			////////// START CLOCK //////////
			(function() {
				function Clock() {
					this.el = document.getElementById("clock");
					this.start("startingTime", this.defaults.countdownInterval);
				}
				
				Clock.prototype.defaults = {
					"startingTime": 3000,
					"countdownInterval": 1000,
					"startText": "GO!",
					"raceTime": 10000,
					"raceInterval": 100,
					"textColor": "black"
				};
				
				Clock.prototype.start = function(howLong, interval) {
					var self = this;
					self.counter = this.defaults[howLong];
					self.timer = setInterval(function() {
							self.countdown(howLong, interval);
						}, interval);
				};
				
				Clock.prototype.countdown = function(howLong, interval) {
					if (this.counter > -1) {
						this.el.innerHTML = this.counter / 1000;
						if (howLong === "raceTime" && this.counter < 3000) {
							this.el.style.color = "red";
						}
					} else {
						if (howLong === "startingTime") {
							this.el.innerHTML = this.defaults.startText;
							game.start();
							clearInterval(this.timer);
							this.start("raceTime",  this.defaults.raceInterval);
						} else if (howLong === "raceTime") {
							clearInterval(this.timer);
							//game.end();
						}
					}
					this.counter -= interval;
				};
				
				window.Clock = Clock;
			})();
			////////// END CLOCK //////////
            
            ////////// START TRACK GENERATION //////////
            (function() {
                function Track() {
                    this.data = getTrackData(this.defaults);
                    this.createView();
                }
                
                Track.prototype.defaults = {
                    "NumberOfLanes" : 10,
                    "NumberOfSegments" : 100,
                    "NumberOfInitialOpenSegments" : 5,
                    "ObstacleFrequency" : 0.1
                };
                
                Track.prototype.createView = function() {
                    this.baseRaster = this.generateRoadLines();
                    this.generateObstacles(this.data);
                };

                Track.prototype.popObstacle = function(segmentIndex, laneIndex) {
                    if (this.data[segmentIndex] && this.data[segmentIndex][laneIndex]) {
                        var tmpObstacle = this.data[segmentIndex][laneIndex];
                        this.data[segmentIndex][laneIndex].remove();
                        this.data[segmentIndex][laneIndex] = 0;
                        return tmpObstacle;
                    } else {
                        return false;
                    }
                };

                window.Track = Track;
            })();
            ////////// END TRACK GENERATION //////////

            ////////// START ROAD LINES //////////
            (function() {
                var numberOfRoadRasters = 10,
                    roadRasterHeight = 200,
                    // calculate combined height to reposition line during onFrame callback
                    combinedRoadLineHeight = numberOfRoadRasters * roadRasterHeight,
                    // first road line is at bottom of view
                    roadLinePosition = new Point(500, view.bounds.height - roadRasterHeight / 2),
                    baseRoadLine = new Raster("roadLine", roadLinePosition),
                    roadLineSymbol = new Symbol(baseRoadLine);
                
                function checkRoadLine(item) {
                    if (view.bounds.y + view.bounds.height < item.bounds.y) {
                        item.position.y -= combinedRoadLineHeight;
                    }
                }
                
                function createRoadLine(i) {
                    var point = roadLinePosition;
                    // subsequent lines are positioned above the previous line
                    point.y -= roadRasterHeight;
                    var placedRoadLine = roadLineSymbol.place(point);
                    placedRoadLine.onFrame = function(e) {
                        checkRoadLine(this);
                    }
                }
                
                function generateRoadLines() {
                    for (var i = 0; i < numberOfRoadRasters; i++) {
                        createRoadLine(i);
                    }
					//game.obstacleLayer = new Layer();
                    return baseRoadLine;
                }
                
                window.Track.prototype.generateRoadLines = generateRoadLines;
            })();
            ////////// END ROAD LINES //////////
            
			
			////////// START OBSTACLES //////////
            (function() {
                var baseObstacle = new Path.Circle({
                        center: [0, 0],
                        radius: 25,
                        fillColor: "black",
                        strokeColor: "yellow"
                    }),
                    obstacleSymbol = new Symbol(baseObstacle);
                
                function createObstacle(x, y) {
                    var point = new Point(x + 50, -y),
                        placedObstacle = obstacleSymbol.place(point);
                    
                    return placedObstacle;
                }
                
                function generateObstacles(data) {
                    var rowHeight = 100,
                        columnWidth = 100,
                        row;
                    for (var y = 0; y < data.length; y++) {
                        row = data[y];
                        for (var x = 0; x < row.length; x++) {
                            switch (row[x]) {
                                case 0: // No Obstacle
                                    break;
                                default: // Obstacle
                                    row[x] = createObstacle(x * columnWidth, y * rowHeight);
                                    break;
                            }
                        }
                    }
                }
                
                window.Track.prototype.generateObstacles = generateObstacles;
            })();
            ////////// END OBSTACLES //////////
			
            
            ////////// START CAMERA //////////
            // Singleton
            (function() {
                function Camera(position, bounds, horizontalAdjustment) {
                    this.zoomInBlocked = false;
                    this.zoomOutBlocked = false;
                    this.bottomPadding = 200;
                
                    this.repositionCamera = function(player1, player2) {
                        var avg = (player1.raster.position/2 + player2.raster.position/2);
                        avg.y -= view.bounds.height / 4;
                        avg.x = this.fixedX;
                        var viewPadding = new Rectangle(view.bounds.x, view.bounds.y, view.bounds.width, view.bounds.height - this.bottomPadding);
                        var intersects = viewPadding.contains(player1.raster.bounds) && viewPadding.contains(player2.raster.bounds);
                        
                        while(!this.zoomOutBlocked && !(view.bounds.contains(player1.raster.bounds) && view.bounds.contains(player2.raster.bounds))) {
                            zoomOut();
                        } 
                        if (!this.zoomInBlocked && view.zoom <= this.minZoom && intersects) {
                            zoomIn();
                        }
                        
                        view.center = avg;
                    }
                    
                    this.unblockZoom = function() {
                        this.zoomInBlocked = false;
                        this.zoomOutBlocked = false;
                    }
                    
                    function zoomOut() {                                    
                        view.zoom -= .01;
                        this.zoomInBlocked = true;
                    }
                    
                    function zoomIn() {                 
                        view.zoom += .01;
                        this.zoomOutBlocked = true;
                    }
                    // init camera
                    view.center = position;
                    while(!view.bounds.contains(bounds)) {
                        zoomOut();
		    }
		    view.center.x += horizontalAdjustment;

                    this.unblockZoom();
                    this.minZoom = view.zoom;
                    this.fixedX = view.center.x;
                    
                    
                    return this;
                }
                window.Camera = Camera;
            })();
            ////////// END CAMERA //////////

            ////////// START PLAYER //////////
            (function() {
                function Player(x, y, color, initialVelocity) {
                    var self = this;
                    //var racecar = new Rectangle(x, y, 100, 100);
		    // +50 to compensate for raster weirdness
                    var carPosition = new Point(x+50, y),
		    racecar = new Raster(color, carPosition);

		    self.raster = racecar;
                    self.initialPositionX = x;
                    self.initialPositionY = y;
                    self.currentLane = 0;

                    self.shape = racecar;
                    self.velocity = initialVelocity;
					
                    self.moveForward = function(tickDuration) {
                        if(!tickDuration) {
                            var tickDuration = 18;
                        }
			// normalize velocity
                        self.raster.position += self.velocity * tickDuration / 18;
                        self.currentDistance = self.initialPositionY - self.raster.position.y;
                    }
                    self.collideWith = function(obstacle) {
                        if (obstacle) {
                            var collisionVelocity = new Point(0,5);
                            self.velocity += collisionVelocity;
                            setTimeout(function() {
                                self.velocity -= collisionVelocity // Restore to normal velocity
                            },200);
                        }
                    }
                    self.currentSegmentIndex = function () {
                        return Math.round(self.currentDistance / config_SegmentDistancePixels);
                    }
                    self.currentLaneIndex = function () {
                        return Math.floor(self.raster.position.x / config_LaneWidthPixels);
                    }

                    return this;
                }
                window.Player = Player;
            })();
            ////////// END PLAYER //////////
			
            var time1;
            function onFrame(event) {
                if (!time1) {
                    time1 = new Date().getTime();
                }
                var time2 = new Date().getTime();
                var delta = time2 - time1;
                time1 = time2;
                document.getElementById("fps").innerHTML = Math.ceil(1/(delta/1000));
                
                if (game.active) {
                    game.player1.moveForward(delta);
                    game.player2.moveForward(delta);

                    game.player1.collideWith(game.track.popObstacle(game.player1.currentSegmentIndex(), game.player1.currentLaneIndex()));
                    game.player2.collideWith(game.track.popObstacle(game.player2.currentSegmentIndex(), game.player2.currentLaneIndex()));

                    game.camera.repositionCamera(game.player1, game.player2);
                }
            }
            
            function onKeyDown(e) {
                // Allow zooming again if a key is pressed
                game.camera.unblockZoom();
                switch(e.key) {
                    case "left":
                        // player2 goes left;
                        var xPos = game.player2.raster.position.getX() - 100;
                        game.player2.raster.position.setX(xPos);
                        return false;
                        break;
                    case "right":
                        // player2 goes right;
                        var xPos = game.player2.raster.position.getX() + 100;
                        game.player2.raster.position.setX(xPos);
                        return false;
                        break;
                    case "a":
                        // player1 goes left;
                        var xPos = game.player1.raster.position.getX() - 100;
                        game.player1.raster.position.setX(xPos);
                        break;
                    case "d":
                        // player1 goes right;
                        var xPos = game.player1.raster.position.getX() + 100;
                        game.player1.raster.position.setX(xPos);
                        break;
                }
            }
            
            document.getElementById("start").onclick = function() {
                game.initialize();
                return false;
            };
			document.getElementById("end").onclick = function() {
				// game.end(); or game.endRace();
				return false;
			};
            if (autoStartGame) {
                game.initialize();
            }
        </script>
        <style>
            html, body {
                background: white;
                margin: 0;
                padding: 0;
            }
            #canvasWrapper {
                margin: 0 auto;
                width: 502px;
            }
            #myCanvas {
                border: 1px solid black;
                background: green;
            }
			#clock {
				float: left;
				font-size: 50px;
			}
        </style>
    </head>
    <body>
		<h1>Ten 2nd's</h1>
		<p style="position: absolute; right: 20px; top: 20px;">fps: <span id="fps"></span></p>
		<p id="clock"></p>
        <div id="canvasWrapper"><canvas id="myCanvas" width="500" height="600"></canvas></div>
        <img src="images/road_line2.gif" id="roadLine" style="display:none;" />
        <img src="images/redcar.gif" id="redcar" style="display:none;" />
		<img src="images/yellowcar.gif" id="yellowcar" style="display:none;" />
		
        <div id="gameMenu">
            <a id="start" href="">Start new game</a>
			<a id="end" href="">End current game</a>
        </div>
		<p>Player 1 score: <span id="score1">0</span></p>
		<p>Player 2 score: <span id="score2">0</span></p>
    </body>
</html>
